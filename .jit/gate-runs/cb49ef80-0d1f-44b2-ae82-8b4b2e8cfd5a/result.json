{
  "schema_version": 1,
  "run_id": "cb49ef80-0d1f-44b2-ae82-8b4b2e8cfd5a",
  "gate_key": "fmt",
  "stage": "postcheck",
  "issue_id": "5e1d5f02-c94d-4f52-9ed6-a633bd6c8f68",
  "commit": "dbf0eee24eda4eaff0cf79f6aa706c90b416ae48",
  "branch": "feature/worktree-parallel-work",
  "status": "failed",
  "started_at": "2026-02-01T17:00:31.010537562Z",
  "completed_at": "2026-02-01T17:00:31.413275427Z",
  "duration_ms": 402,
  "exit_code": 1,
  "stdout": "Diff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/commands/claim.rs:126:\n /// # Returns\n ///\n /// The renewed lease with updated expiry time\n\u001b[31m-pub fn execute_claim_renew<S: IssueStore>(\n\u001b[m\u001b[31m-    lease_id: &str,\n\u001b[m\u001b[31m-    extension_secs: u64,\n\u001b[m\u001b[31m-) -> Result<Lease> {\n\u001b[m\u001b[32m+pub fn execute_claim_renew<S: IssueStore>(lease_id: &str, extension_secs: u64) -> Result<Lease> {\n\u001b[m     use crate::agent_config::resolve_agent_id;\n \n     // Detect worktree context\nDiff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/commands/claim.rs:252:\n /// # Returns\n ///\n /// Ok(()) on success\n\u001b[31m-pub fn execute_claim_force_evict<S: IssueStore>(\n\u001b[m\u001b[31m-    lease_id: &str,\n\u001b[m\u001b[31m-    reason: &str,\n\u001b[m\u001b[31m-) -> Result<()> {\n\u001b[m\u001b[32m+pub fn execute_claim_force_evict<S: IssueStore>(lease_id: &str, reason: &str) -> Result<()> {\n\u001b[m     // Detect worktree context\n     let paths = WorktreePaths::detect()\n         .context(\"Failed to detect worktree paths - are you in a git repository?\")?;\nDiff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/config.rs:421:\n \"#;\n         let config: JitConfig = toml::from_str(config_toml).unwrap();\n         let worktree = config.worktree.unwrap();\n\u001b[31m-        assert_eq!(worktree.enforcement_mode().unwrap(), EnforcementMode::Strict);\n\u001b[m\u001b[32m+        assert_eq!(\n\u001b[m\u001b[32m+            worktree.enforcement_mode().unwrap(),\n\u001b[m\u001b[32m+            EnforcementMode::Strict\n\u001b[m\u001b[32m+        );\n\u001b[m     }\n \n     #[test]\nDiff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/config.rs:432:\n \"#;\n         let config: JitConfig = toml::from_str(config_toml).unwrap();\n         let worktree = config.worktree.unwrap();\n\u001b[31m-        assert_eq!(worktree.enforcement_mode().unwrap(), EnforcementMode::Strict);\n\u001b[m\u001b[32m+        assert_eq!(\n\u001b[m\u001b[32m+            worktree.enforcement_mode().unwrap(),\n\u001b[m\u001b[32m+            EnforcementMode::Strict\n\u001b[m\u001b[32m+        );\n\u001b[m     }\n \n     #[test]\nDiff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/config_manager.rs:92:\n     /// ```\n     pub fn get_enforcement_mode(&self) -> Result<crate::config::EnforcementMode> {\n         let config = self.load()?;\n\u001b[31m-        \n\u001b[m\u001b[32m+\n\u001b[m         if let Some(worktree_config) = config.worktree {\n             worktree_config.enforcement_mode()\n         } else {\nDiff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/config_manager.rs:300:\n \n         let config_mgr = ConfigManager::new(&jit_dir);\n         let mode = config_mgr.get_enforcement_mode().unwrap();\n\u001b[31m-        \n\u001b[m\u001b[32m+\n\u001b[m         // Default to Strict when no config exists\n         assert_eq!(mode, crate::config::EnforcementMode::Strict);\n     }\nDiff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/config_manager.rs:319:\n \n         let config_mgr = ConfigManager::new(&jit_dir);\n         let mode = config_mgr.get_enforcement_mode().unwrap();\n\u001b[31m-        \n\u001b[m\u001b[32m+\n\u001b[m         assert_eq!(mode, crate::config::EnforcementMode::Warn);\n     }\n \nDiff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/config_manager.rs:337:\n \n         let config_mgr = ConfigManager::new(&jit_dir);\n         let result = config_mgr.get_enforcement_mode();\n\u001b[31m-        \n\u001b[m\u001b[32m+\n\u001b[m         assert!(result.is_err());\n\u001b[31m-        assert!(result.unwrap_err().to_string().contains(\"Invalid enforce_leases mode\"));\n\u001b[m\u001b[32m+        assert!(result\n\u001b[m\u001b[32m+            .unwrap_err()\n\u001b[m\u001b[32m+            .to_string()\n\u001b[m\u001b[32m+            .contains(\"Invalid enforce_leases mode\"));\n\u001b[m     }\n }\n \nDiff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/storage/memory.rs:47:\n         // Generate unique root path for parallel test isolation\n         let unique_id = uuid::Uuid::new_v4();\n         let root_path = std::path::PathBuf::from(format!(\"/tmp/jit-test-{}\", unique_id));\n\u001b[31m-        \n\u001b[m\u001b[32m+\n\u001b[m         Self {\n             issues: Arc::new(Mutex::new(HashMap::new())),\n             gate_registry: Arc::new(Mutex::new(GateRegistry::default())),\nDiff in /home/vkaskivuo/Projects/just-in-time/crates/jit/src/main.rs:2275:\n                 use jit::commands::claim::execute_claim_status;\n                 use jit::output::{JsonError, JsonOutput};\n \n\u001b[31m-                match execute_claim_status::<jit::JsonFileStorage>(issue.as_deref(), agent.as_deref()) {\n\u001b[m\u001b[32m+                match execute_claim_status::<jit::JsonFileStorage>(\n\u001b[m\u001b[32m+                    issue.as_deref(),\n\u001b[m\u001b[32m+                    agent.as_deref(),\n\u001b[m\u001b[32m+                ) {\n\u001b[m                     Ok(leases) => {\n                         if json {\n                             let response = serde_json::json!({\n",
  "stderr": "",
  "command": "cargo fmt -- --check",
  "by": "auto:executor",
  "message": null
}
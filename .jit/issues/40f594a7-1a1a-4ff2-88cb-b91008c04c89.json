{
  "id": "40f594a7-1a1a-4ff2-88cb-b91008c04c89",
  "title": "Design decision: State transition behavior in bulk operations",
  "description": "## Problem\n\nBulk update operations bypass `update_issue_state()` and its associated business logic, including auto-transition behavior. This creates inconsistency between single-issue and bulk operations.\n\n## Current Behavior\n\n**Single-issue state update:**\n```rust\n// In update_issue_state() - has smart logic\nfn update_issue_state(issue_id: &str, new_state: State) -> Result<()> {\n    // Checks gates, dependencies\n    // Applies auto-transitions (e.g., backlog → ready when deps complete)\n    // Complex business logic\n}\n```\n\n**Bulk state update:**\n```rust\n// In apply_operations_to_issue() - direct assignment\nupdated.state = new_state;  // No business logic!\n```\n\n## Inconsistency Examples\n\n### Example 1: Auto-Transition Not Applied\n\n**Single-issue:**\n```bash\n# When dependencies complete, might auto-advance from backlog to ready\njit issue update abc123 --state ready\n# Smart: checks deps, might advance to ready\n```\n\n**Bulk:**\n```bash\njit issue update --filter \"epic:*\" --state ready\n# Dumb: just sets state, no auto-transitions\n```\n\n### Example 2: Gate-Triggered State Changes\n\n**Single-issue:**\n- Passing last required gate might auto-transition to Done\n- Complex orchestration logic\n\n**Bulk:**\n- Just sets the state you specify\n- No orchestration\n\n## Decision Needed\n\nWe need to decide: Should bulk operations be \"smart\" (apply business logic) or \"dumb\" (literal operations)?\n\n### Option A: Shared Logic (Smart Bulk) ⭐ More Consistent\n\n**Approach:**\n- Extract state transition logic to shared function\n- Both single and bulk operations call it\n- Auto-transitions happen in bulk\n\n**Implementation:**\n```rust\n// Extract shared logic\nfn apply_state_transition(\n    issue: &mut Issue,\n    new_state: State,\n    all_issues: &[Issue],\n) -> Result<StateTransitionResult> {\n    // All the smart logic from update_issue_state()\n    // Auto-transitions, gate checks, etc.\n    // Returns what actually happened\n}\n\n// Use in both places\nimpl CommandExecutor {\n    fn update_issue_state(...) {\n        apply_state_transition(...)?;\n    }\n    \n    fn apply_operations_to_issue(...) {\n        apply_state_transition(...)?;\n    }\n}\n```\n\n**Pros:**\n- Consistent behavior (no surprises)\n- All business logic applied uniformly\n- Less code duplication\n- Future changes propagate automatically\n\n**Cons:**\n- More complex bulk operations\n- Harder to predict exact results\n- Auto-transitions might surprise users\n- More edge cases to handle\n\n### Option B: Document Differences (Dumb Bulk) ⭐ More Predictable\n\n**Approach:**\n- Keep bulk operations literal (set exactly what you specify)\n- Document the difference clearly\n- Accept the inconsistency\n\n**Implementation:**\n```rust\n// Current implementation - just document it better\nfn apply_operations_to_issue(...) {\n    // DESIGN: Bulk operations are literal - they set exactly what you specify.\n    // This differs from single-issue updates which apply auto-transitions.\n    // Rationale: Bulk operations are power tools - explicit behavior is safer.\n    updated.state = new_state;\n}\n```\n\n**Documentation:**\n```markdown\n## Bulk vs Single-Issue Operations\n\n**Single-issue updates are \"smart\":**\n- Apply auto-transitions (backlog → ready when deps complete)\n- Orchestrate gate-triggered state changes\n- Complex business logic\n\n**Bulk updates are \"literal\":**\n- Set exactly the state you specify\n- No auto-transitions\n- Predictable, explicit behavior\n- You can layer multiple operations if needed\n\nThis design makes bulk operations more predictable and safer for\nlarge-scale changes.\n```\n\n**Pros:**\n- Simpler implementation (current code)\n- More predictable (users know exactly what happens)\n- Safer for large operations (no hidden side effects)\n- Easier to reason about\n\n**Cons:**\n- Inconsistent with single-issue behavior\n- Users might be surprised initially\n- More manual work for complex workflows\n- Documentation burden\n\n### Option C: Hybrid Approach\n\n**Approach:**\n- Add `--smart` / `--literal` flag to bulk operations\n- Default to one behavior, allow override\n\n**Pros:**\n- Maximum flexibility\n- Users choose their tradeoff\n\n**Cons:**\n- More complexity\n- Two code paths to maintain\n- Confusing for users (which should I use?)\n\n## Recommendation\n\n**Option B: Document Differences (Dumb Bulk)**\n\n**Rationale:**\n1. **Principle of Least Surprise:** When operating on 100+ issues, explicit behavior is less surprising than magic auto-transitions\n2. **Safety:** Bulk operations are power tools - users should know exactly what they're changing\n3. **Composability:** Users can layer multiple bulk operations to achieve complex workflows\n4. **Simplicity:** Current implementation is clean and working\n5. **Precedent:** Similar tools (SQL UPDATE, jq, sed) are literal, not smart\n\n**Implementation:**\n- Keep current code\n- Add comprehensive documentation in code comments\n- Update user documentation (EXAMPLE.md)\n- Add FAQ: \"Why don't bulk operations auto-transition like single updates?\"\n\n## Acceptance Criteria\n\n### If Option A (Shared Logic):\n- [ ] Extract state transition logic to shared function\n- [ ] Both single and bulk use same function\n- [ ] Auto-transitions work in bulk\n- [ ] Tests verify consistent behavior\n- [ ] Document the consistency\n\n### If Option B (Document Differences):\n- [ ] Add clear doc comments in code explaining the difference\n- [ ] Update EXAMPLE.md with bulk vs single comparison\n- [ ] Add FAQ section explaining design rationale\n- [ ] No code changes needed\n- [ ] Tests verify current behavior\n\n### If Option C (Hybrid):\n- [ ] Implement both code paths\n- [ ] Add `--smart` / `--literal` flag\n- [ ] Tests for both modes\n- [ ] Document when to use each\n\n## Related Issues\n\n- f5ce80bc - Parent issue (bulk operations)\n- This decision affects Phase 4 (CLI integration)\n\n## Priority\n\n**HIGH - Blocks clear documentation**\n\nNot blocking functionally, but we need to decide and document before shipping.\n\n## Estimated Effort\n\n**Option A:** 3-4 hours (refactoring + tests)  \n**Option B:** 30 minutes (documentation only)  \n**Option C:** 4-5 hours (full implementation)",
  "state": "done",
  "priority": "high",
  "assignee": "agent:copilot",
  "dependencies": [],
  "gates_required": [],
  "gates_status": {},
  "context": {},
  "documents": [
    {
      "path": "dev/sessions/session-2025-12-30-bulk-state-decision.md",
      "commit": null,
      "label": "Design Decision Document",
      "doc_type": "design",
      "format": "markdown"
    }
  ],
  "labels": [
    "type:decision",
    "epic:production-stability",
    "milestone:v1.0",
    "component:core"
  ]
}
{
  "id": "12ef7efb-956e-4456-bd89-237ebfe22937",
  "title": "Centralize label matching logic in labels module",
  "description": "## Problem\n\nLabel matching logic (especially wildcard matching) is scattered across multiple files:\n\n**Current state:**\n- Basic validation/parsing: `labels.rs` (`validate_label`, `parse_label`)\n- Wildcard matching: Duplicated in `commands/query.rs::query_by_label()`\n- Pattern matching: Reimplemented in `query/evaluator.rs`\n\nThis duplication makes the logic:\n- Hard to discover and reuse\n- Prone to inconsistency\n- Difficult to test comprehensively in one place\n\n## Current Duplication\n\n```rust\n// In commands/query.rs\nif value == \"*\" {\n    issues.into_iter()\n        .filter(|issue| {\n            issue.labels.iter().any(|label| {\n                if let Ok((ns, _)) = label_utils::parse_label(label) {\n                    ns == namespace\n                } else {\n                    false\n                }\n            })\n        })\n        .collect()\n}\n\n// Similar logic in query/evaluator.rs\nif pattern.ends_with(\":*\") {\n    let namespace = &pattern[..pattern.len() - 2];\n    issue.labels.iter().any(|label| {\n        labels::parse_label(label)\n            .map(|(ns, _)| ns == namespace)\n            .unwrap_or(false)\n    })\n}\n```\n\n## Desired Approach\n\nCentralize all label matching logic in `labels.rs`:\n\n```rust\n// In labels.rs\n\n/// Check if a pattern matches any label in a collection\n///\n/// Supports:\n/// - Exact match: \"epic:auth\" matches only \"epic:auth\"\n/// - Wildcard: \"epic:*\" matches any label in epic namespace\n///\n/// # Examples\n///\n/// ```\n/// use jit::labels::matches_pattern;\n///\n/// let labels = vec![\"epic:auth\".to_string(), \"type:task\".to_string()];\n/// assert!(matches_pattern(&labels, \"epic:auth\"));\n/// assert!(matches_pattern(&labels, \"epic:*\"));\n/// assert!(!matches_pattern(&labels, \"milestone:*\"));\n/// ```\npub fn matches_pattern(issue_labels: &[String], pattern: &str) -> bool {\n    if pattern.ends_with(\":*\") {\n        // Wildcard: match any label in namespace\n        let namespace = &pattern[..pattern.len() - 2];\n        issue_labels.iter().any(|label| {\n            parse_label(label)\n                .map(|(ns, _)| ns == namespace)\n                .unwrap_or(false)\n        })\n    } else {\n        // Exact match\n        issue_labels.contains(&pattern.to_string())\n    }\n}\n\n/// Check if a single label matches a pattern\npub fn label_matches(label: &str, pattern: &str) -> bool {\n    matches_pattern(&[label.to_string()], pattern)\n}\n```\n\n## Implementation Steps\n\n1. Add `matches_pattern()` function to `labels.rs`\n2. Add comprehensive tests in `labels.rs`\n3. Update `commands/query.rs::query_by_label()` to use new function\n4. Update `query/evaluator.rs` to use new function\n5. Remove duplicated matching logic\n6. Update documentation\n\n## Benefits\n\n- Single source of truth for label matching\n- Easier to discover and use\n- Comprehensive tests in one place\n- Consistent behavior across codebase\n- Easier to extend (e.g., add regex patterns later)\n\n## Acceptance Criteria\n\n- [ ] `matches_pattern()` function in labels.rs\n- [ ] Tests cover exact match and wildcard patterns\n- [ ] Tests cover edge cases (invalid labels, empty namespace, etc.)\n- [ ] `query_by_label()` uses new function\n- [ ] Query evaluator uses new function\n- [ ] No duplicated wildcard matching logic\n- [ ] All existing tests pass",
  "state": "done",
  "priority": "normal",
  "assignee": "agent:copilot-cli",
  "dependencies": [],
  "gates_required": [],
  "gates_status": {},
  "context": {},
  "documents": [],
  "labels": [
    "type:task",
    "epic:production-polish",
    "component:core"
  ],
  "created_at": "2026-02-11T00:48:06.107710+02:00",
  "updated_at": "2026-02-10T22:48:06.107834836Z"
}

{
  "id": "fe91699f-7c1a-430b-bcb9-c6f80202c124",
  "title": "Add state transition checks to jit validate --fix",
  "description": "## Problem\n\nAfter merging worktrees, issues in \"backlog\" state may have all dependencies completed but never auto-transition to \"ready\" state. This happens because `check_auto_transitions()` only runs when an issue is actively updated to a terminal state, not when worktree JSON files are merged via git.\n\n## Example Scenario\n\n1. Story A has 6 task dependencies\n2. Tasks are completed in parallel across 3 agent worktrees\n3. Each task completion triggers `check_auto_transitions()` in that worktree\n4. But Story A is in main worktree's `.jit/` directory\n5. When agent branches are merged, Story A's JSON file is untouched\n6. Result: Story A stuck in \"backlog\" despite all dependencies done\n\n## Root Cause\n\nThe auto-transition logic in `commands/issue.rs::check_auto_transitions()` exists and works correctly for single-worktree workflows. However, it doesn't run post-merge when issue state is updated via git merge rather than `jit issue update`.\n\n## Proposed Solution\n\nAdd state transition validation to `jit validate --fix`:\n\n```rust\n// In validate.rs::validate_with_fix()\nif fix {\n    // ... existing fixes ...\n    \n    // Fix pending state transitions\n    let transition_fixes = self.check_pending_transitions(dry_run, quiet)?;\n    total_fixes += transition_fixes;\n}\n\n// New method\nfn check_pending_transitions(&self, dry_run: bool, quiet: bool) -> Result<usize> {\n    let issues = self.storage.list_issues()?;\n    let resolved: HashMap<String, &Issue> = issues.iter()\n        .map(|i| (i.id.clone(), i))\n        .collect();\n    \n    let backlog_issues: Vec<_> = issues.iter()\n        .filter(|i| i.state == State::Backlog)\n        .collect();\n    \n    let mut fixed = 0;\n    for issue in backlog_issues {\n        if issue.should_auto_transition_to_ready(&resolved) {\n            if !quiet {\n                println!(\"  \u2192 Transitioning {} to ready (dependencies complete)\", \n                    issue.id_short());\n            }\n            \n            if !dry_run {\n                self.auto_transition_to_ready(&issue.id)?;\n            }\n            fixed += 1;\n        }\n    }\n    \n    Ok(fixed)\n}\n```\n\n## Benefits\n\n- Worktree merges work correctly without manual intervention\n- `jit validate --fix` becomes comprehensive consistency repair tool\n- Consistent behavior whether working in single worktree or parallel mode\n- Clear fix message shows which issues auto-transitioned\n\n## Alternative: Startup Recovery\n\nCould also add to `startup_recovery()` routine in the Recovery story, but that runs on every command which may be overkill. `jit validate --fix` is more explicit and appropriate for post-merge cleanup.\n\n## Testing\n\n- Simulate worktree merge scenario\n- Verify backlog issues transition when dependencies complete\n- Ensure no false positives (issues with incomplete deps stay in backlog)\n- Test with `--dry-run` flag\n\n## References\n\n- Existing auto-transition logic: `crates/jit/src/commands/issue.rs:451-512`\n- Parallel work design: `dev/design/worktree-parallel-work.md`\n- Recovery story: 92bf3a9b-914a-4015-8d26-b52535afe479",
  "state": "done",
  "priority": "high",
  "assignee": "copilot:cli-session",
  "dependencies": [],
  "gates_required": [],
  "gates_status": {},
  "context": {},
  "documents": [],
  "labels": [
    "type:task",
    "epic:parallel-work",
    "milestone:v1.0",
    "component:cli"
  ],
  "created_at": "2026-01-07T21:10:56.505380236Z",
  "updated_at": "2026-02-02T12:26:54.249881609Z"
}

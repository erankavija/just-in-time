{
  "id": "f65b5b9c-521c-4aab-bb36-0fc99a0efecf",
  "title": "Extract issue context helper to reduce boilerplate",
  "description": "## Problem\n\nMultiple query functions manually build the same `HashMap<String, &Issue>` pattern for dependency checking:\n\n```rust\n// Repeated in query_ready(), query_blocked(), etc.\nlet issue_refs: Vec<&Issue> = issues.iter().collect();\nlet resolved: HashMap<String, &Issue> = \n    issue_refs.iter().map(|i| (i.id.clone(), *i)).collect();\n```\n\nIssues:\n- Boilerplate repeated across 5+ functions\n- Temporary `issue_refs` vec seems unnecessary\n- Easy to forget when adding new query functions\n- Makes code harder to read (ceremony before actual logic)\n\n## Current Pattern\n\n```rust\npub fn query_ready(&self) -> Result<Vec<Issue>> {\n    let issues = self.storage.list_issues()?;\n    let issue_refs: Vec<&Issue> = issues.iter().collect();  // Boilerplate\n    let resolved: HashMap<String, &Issue> =                  // Boilerplate\n        issue_refs.iter().map(|i| (i.id.clone(), *i)).collect();\n\n    let ready: Vec<Issue> = issues.iter()\n        .filter(|i| i.state == State::Ready && !i.is_blocked(&resolved))\n        .cloned()\n        .collect();\n\n    Ok(ready)\n}\n```\n\n## Desired Pattern\n\n```rust\n// In commands/mod.rs or domain.rs\nfn build_issue_map(issues: &[Issue]) -> HashMap<String, &Issue> {\n    issues.iter().map(|i| (i.id.clone(), i)).collect()\n}\n\n// Usage (cleaner)\npub fn query_ready(&self) -> Result<Vec<Issue>> {\n    let issues = self.storage.list_issues()?;\n    let resolved = build_issue_map(&issues);  // One line\n\n    let ready: Vec<Issue> = issues.iter()\n        .filter(|i| i.state == State::Ready && !i.is_blocked(&resolved))\n        .cloned()\n        .collect();\n\n    Ok(ready)\n}\n```\n\n## Implementation\n\n1. Add `build_issue_map()` helper in appropriate module\n2. Update all query functions to use helper:\n   - `query_ready()`\n   - `query_blocked()`\n   - Any other functions using this pattern\n3. Update `QueryContext::from_issues()` to use same helper\n4. Add tests if needed\n5. Update documentation\n\n## Alternative: Use QueryContext Directly\n\nCould also standardize on `QueryContext` pattern:\n\n```rust\npub fn query_ready(&self) -> Result<Vec<Issue>> {\n    let issues = self.storage.list_issues()?;\n    let context = QueryContext::from_issues(&issues);\n    \n    let ready: Vec<Issue> = issues.iter()\n        .filter(|i| i.state == State::Ready && !i.is_blocked(&context.all_issues))\n        .cloned()\n        .collect();\n\n    Ok(ready)\n}\n```\n\n## Benefits\n\n- Less boilerplate (2 lines â†’ 1 line)\n- More readable code\n- Consistent pattern across codebase\n- Harder to make mistakes\n\n## Acceptance Criteria\n\n- [ ] Helper function created (decide location)\n- [ ] All query functions updated to use helper\n- [ ] No more manual HashMap construction for issue context\n- [ ] All existing tests pass\n- [ ] Code is more readable",
  "state": "in_progress",
  "priority": "low",
  "assignee": "agent:copilot-session",
  "dependencies": [],
  "gates_required": [],
  "gates_status": {},
  "context": {},
  "documents": [],
  "labels": [
    "type:task",
    "epic:production-polish",
    "component:core"
  ],
  "created_at": "2025-12-30T22:32:59.465019245Z",
  "updated_at": "2025-12-30T22:32:59.465019245Z"
}
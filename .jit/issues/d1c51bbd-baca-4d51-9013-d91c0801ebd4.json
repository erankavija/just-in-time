{
  "id": "d1c51bbd-baca-4d51-9013-d91c0801ebd4",
  "title": "Add field-level validation to bulk update operations",
  "description": "## Problem\n\nBulk update operations currently lack field-level validation, allowing invalid data to be set on issues. This is inconsistent with single-issue update behavior and could lead to data integrity issues.\n\n## Current Behavior\n\n```rust\n// In apply_operations_to_issue() - NO field validation\nfor label in &operations.add_labels {\n    if !updated.labels.contains(label) {\n        updated.labels.push(label.clone());  // No validation!\n    }\n}\n```\n\n## Missing Validations\n\n### 1. Label Validation\n- **Format validation:** Not checking `namespace:value` format\n- **Hierarchy validation:** Not enforcing type hierarchy (milestone > epic > task)\n- **Uniqueness constraints:** Not checking namespace uniqueness (e.g., only one `type:*` label)\n- **Invalid labels:** Could add malformed labels that break queries\n\n### 2. Assignee Validation\n- **Format validation:** Not checking `type:identifier` format\n- **Invalid formats:** Could set assignee to invalid string\n\n### 3. Priority Validation\n- Already safe (enum type constraint)\n- But no explicit validation in bulk path\n\n## Inconsistency with Single-Issue Updates\n\n`create_issue()` and `update_issue()` have comprehensive validation:\n```rust\n// In create_issue()\nfor label_str in &labels {\n    label_utils::validate_label(label_str)?;  // Format check\n}\n\n// Check uniqueness constraints\nfor label_str in &labels {\n    if let Ok((namespace, _)) = label_utils::parse_label(label_str) {\n        if let Some(ns_config) = namespaces.get(&namespace) {\n            if ns_config.unique && !unique_namespaces_seen.insert(namespace.clone()) {\n                return Err(anyhow!(\"Cannot add multiple labels...\"));\n            }\n        }\n    }\n}\n```\n\nBulk updates skip ALL of this validation.\n\n## Example Failure Scenarios\n\n```bash\n# Invalid label format - should reject\njit issue update --filter \"state:ready\" --add-label \"bad_label_no_colon\"\n\n# Violate hierarchy - should reject  \njit issue update --filter \"type:epic\" --add-label \"type:task\"\n\n# Invalid assignee format - should reject\njit issue update --filter \"state:ready\" --assignee \"not-a-valid-format\"\n```\n\nCurrently these all succeed, corrupting issue data.\n\n## Proposed Solution\n\n### Step 1: Extract Validation Functions\n\nCreate reusable validation in `validation` module:\n\n```rust\n// In validation.rs or labels.rs\npub fn validate_label_operation(\n    existing_labels: &[String],\n    add_labels: &[String],\n    remove_labels: &[String],\n    namespaces: &HashMap<String, NamespaceConfig>,\n) -> Result<()> {\n    // Check format\n    for label in add_labels {\n        validate_label(label)?;\n    }\n    \n    // Check uniqueness constraints\n    let final_labels = compute_final_labels(existing_labels, add_labels, remove_labels);\n    check_uniqueness_constraints(&final_labels, namespaces)?;\n    \n    Ok(())\n}\n\npub fn validate_assignee_format(assignee: &str) -> Result<()> {\n    // Check \"type:identifier\" format\n    if !assignee.contains(':') {\n        return Err(anyhow!(\"Assignee must be in format 'type:identifier'\"));\n    }\n    Ok(())\n}\n```\n\n### Step 2: Call Validation in Bulk Updates\n\n```rust\nfn apply_operations_to_issue(...) -> Result<bool> {\n    // Load config for validation\n    let config = self.config_manager.load()?;\n    let namespaces = self.config_manager.get_namespaces()?;\n    \n    // Validate label operations\n    if !operations.add_labels.is_empty() || !operations.remove_labels.is_empty() {\n        validate_label_operation(\n            &updated.labels,\n            &operations.add_labels,\n            &operations.remove_labels,\n            &namespaces,\n        )?;\n    }\n    \n    // Validate assignee\n    if let Some(ref assignee) = operations.assignee {\n        validate_assignee_format(assignee)?;\n    }\n    \n    // Then apply changes...\n}\n```\n\n### Step 3: Add Validation Tests\n\n```rust\n#[test]\nfn test_bulk_update_rejects_invalid_label_format() {\n    // Should reject \"bad_label\" (no colon)\n}\n\n#[test]\nfn test_bulk_update_rejects_hierarchy_violation() {\n    // Epic with type:task should fail\n}\n\n#[test]\nfn test_bulk_update_rejects_duplicate_unique_namespace() {\n    // Adding second type:* label should fail\n}\n\n#[test]\nfn test_bulk_update_rejects_invalid_assignee_format() {\n    // \"invalid\" should fail, \"agent:copilot\" should pass\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Extract label validation to reusable function\n- [ ] Extract assignee validation to reusable function\n- [ ] Call validations in `apply_operations_to_issue()` before modifications\n- [ ] Add tests for validation rejection scenarios\n- [ ] All validations consistent with single-issue behavior\n- [ ] Clear error messages for validation failures\n- [ ] All existing tests still pass\n\n## Priority\n\n**CRITICAL - BLOCKING for Phase 4**\n\nWithout this, bulk operations could corrupt issue data and violate invariants. Must be fixed before proceeding with CLI integration.\n\n## Estimated Effort\n\n2-3 hours:\n- 1 hour: Extract and refactor validation functions\n- 1 hour: Integrate into bulk update path\n- 30 min: Tests\n- 30 min: Verification and cleanup",
  "state": "done",
  "priority": "critical",
  "assignee": "agent:copilot",
  "dependencies": [],
  "gates_required": [],
  "gates_status": {},
  "context": {},
  "documents": [
    {
      "path": "dev/sessions/session-2025-12-30-bulk-validation.md",
      "commit": null,
      "label": "Implementation Summary",
      "doc_type": "notes",
      "format": "markdown"
    }
  ],
  "labels": [
    "type:task",
    "epic:production-stability",
    "milestone:v1.0",
    "component:core"
  ],
  "created_at": "2025-12-30T23:04:30.383772371Z",
  "updated_at": "2025-12-30T23:04:30.380949790Z"
}

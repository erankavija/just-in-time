//! Worktree identity generation and persistence.
//!
//! This module provides deterministic worktree ID generation and persistence
//! to support parallel multi-agent work with git worktrees.

use anyhow::{Context, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};


/// Worktree identity persisted in `<worktree>/.jit/worktree.json`.
///
/// The worktree ID is stable across relocations to support lease continuity.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct WorktreeIdentity {
    /// Schema version for future compatibility
    pub schema_version: u32,

    /// Stable worktree identifier (format: "wt:{8-hex-chars}")
    pub worktree_id: String,

    /// Current git branch
    pub branch: String,

    /// Absolute path to worktree root (updated on relocation)
    pub root: String,

    /// When this worktree identity was created
    pub created_at: DateTime<Utc>,

    /// When this worktree was relocated (if applicable)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub relocated_at: Option<DateTime<Utc>>,
}

/// Generate a deterministic worktree ID from path and timestamp.
///
/// The ID is generated by hashing the absolute path and creation timestamp,
/// then truncating to 8 hex characters for readability.
///
/// # Format
///
/// `wt:{8-hex-chars}` (e.g., `wt:abc123ef`)
///
/// # Examples
///
/// ```
/// use std::path::PathBuf;
/// use chrono::Utc;
/// use jit::storage::worktree_identity::generate_worktree_id;
///
/// let path = PathBuf::from("/path/to/worktree");
/// let timestamp = Utc::now();
/// let id = generate_worktree_id(&path, timestamp);
///
/// assert!(id.starts_with("wt:"));
/// assert_eq!(id.len(), 11); // "wt:" + 8 hex chars
/// ```
pub fn generate_worktree_id(path: &Path, created_at: DateTime<Utc>) -> String {
    let mut hasher = Sha256::new();
    hasher.update(path.to_string_lossy().as_bytes());
    hasher.update(created_at.to_rfc3339().as_bytes());
    let hash = hasher.finalize();

    // Truncate to first 4 bytes (8 hex chars)
    format!("wt:{}", hex::encode(&hash[..4]))
}

/// Load or create worktree identity.
///
/// If `worktree.json` exists, load it and check for relocation.
/// If it doesn't exist, generate a new identity and persist it.
///
/// # Relocation Detection
///
/// When the stored root path differs from the current path:
/// - Update `root` to current path
/// - Set `relocated_at` timestamp
/// - Preserve `worktree_id` (stable across moves)
/// - Write atomically (temp file + rename)
///
/// # Arguments
///
/// * `jit_dir` - Path to `.jit` directory
/// * `worktree_root` - Current absolute path to worktree root
/// * `branch` - Current git branch name
///
/// # Examples
///
/// ```no_run
/// use std::path::PathBuf;
/// use jit::storage::worktree_identity::load_or_create_worktree_identity;
///
/// let jit_dir = PathBuf::from("/path/to/worktree/.jit");
/// let worktree_root = PathBuf::from("/path/to/worktree");
/// let branch = "main".to_string();
///
/// let identity = load_or_create_worktree_identity(&jit_dir, &worktree_root, &branch)
///     .expect("Failed to load/create worktree identity");
///
/// println!("Worktree ID: {}", identity.worktree_id);
/// ```
pub fn load_or_create_worktree_identity(
    jit_dir: &Path,
    worktree_root: &Path,
    branch: &str,
) -> Result<WorktreeIdentity> {
    use crate::storage::worktree_paths::WorktreePaths;

    let wt_file = jit_dir.join("worktree.json");

    if wt_file.exists() {
        // Load existing identity
        let content = fs::read_to_string(&wt_file).context("Failed to read worktree.json")?;
        let mut identity: WorktreeIdentity =
            serde_json::from_str(&content).context("Failed to parse worktree.json")?;

        // Check for path mismatch
        let current_root = worktree_root.to_string_lossy().to_string();
        if identity.root != current_root {
            // Path mismatch - could be relocation OR copied file from git worktree add
            // Detect if we're in a git worktree (not main)
            let is_secondary_worktree = WorktreePaths::detect()
                .map(|paths| paths.is_worktree())
                .unwrap_or(false);

            if is_secondary_worktree {
                // In a git worktree with wrong path - could be copied OR moved
                // Check if old path still exists with the same ID
                let old_path = PathBuf::from(&identity.root);
                let old_wt_file = old_path.join(".jit").join("worktree.json");
                
                let is_copy = if old_wt_file.exists() {
                    // Old path exists - check if it has the same ID
                    if let Ok(old_content) = fs::read_to_string(&old_wt_file) {
                        if let Ok(old_identity) = serde_json::from_str::<WorktreeIdentity>(&old_content) {
                            // If IDs match, this is a copy (both have same ID)
                            old_identity.worktree_id == identity.worktree_id
                        } else {
                            // Can't parse old file - treat as copy to be safe
                            true
                        }
                    } else {
                        // Can't read old file - treat as copy to be safe
                        true
                    }
                } else {
                    // Old path doesn't exist - this is a move
                    false
                };

                if is_copy {
                    // This is a copied file from git worktree add
                    // Delete it and create a new identity with unique ID
                    fs::remove_file(&wt_file).context("Failed to remove copied worktree.json")?;
                    // Fall through to create new identity
                } else {
                    // This is a moved worktree (e.g., git worktree move)
                    eprintln!(
                        "⚠️  Worktree relocated: {} -> {}",
                        identity.root, current_root
                    );

                    identity.root = current_root;
                    identity.relocated_at = Some(Utc::now());

                    // Write updated identity atomically
                    write_identity_atomic(&wt_file, &identity)?;

                    return Ok(identity);
                }
            } else {
                // Not in a git worktree - this is a genuine relocation
                eprintln!(
                    "⚠️  Worktree relocated: {} -> {}",
                    identity.root, current_root
                );

                identity.root = current_root;
                identity.relocated_at = Some(Utc::now());

                // Write updated identity atomically
                write_identity_atomic(&wt_file, &identity)?;

                return Ok(identity);
            }
        } else {
            // Paths match - use existing identity
            return Ok(identity);
        }
    }

    // Create new identity (either no file existed, or we deleted a copied one)
    let now = Utc::now();
    let worktree_id = generate_worktree_id(worktree_root, now);

    let identity = WorktreeIdentity {
        schema_version: 1,
        worktree_id,
        branch: branch.to_string(),
        root: worktree_root.to_string_lossy().to_string(),
        created_at: now,
        relocated_at: None,
    };

    // Ensure .jit directory exists
    fs::create_dir_all(jit_dir).context("Failed to create .jit directory")?;

    // Write atomically
    write_identity_atomic(&wt_file, &identity)?;

    Ok(identity)
}

/// Write worktree identity atomically using temp file + rename pattern.
///
/// This ensures the file is never in a partially written state, even if
/// the process crashes mid-write.
fn write_identity_atomic(path: &Path, identity: &WorktreeIdentity) -> Result<()> {
    let temp_path = path.with_extension("tmp");

    // Write to temp file
    let json =
        serde_json::to_string_pretty(identity).context("Failed to serialize worktree identity")?;

    let mut file = fs::File::create(&temp_path).context("Failed to create temp file")?;

    file.write_all(json.as_bytes())
        .context("Failed to write to temp file")?;

    // Fsync to ensure data is on disk
    file.sync_all().context("Failed to fsync temp file")?;

    drop(file);

    // Atomic rename
    fs::rename(&temp_path, path).context("Failed to rename temp file")?;

    // Fsync parent directory to ensure rename is durable
    let parent = path.parent().context("No parent directory")?;
    let parent_file = fs::File::open(parent).context("Failed to open parent directory")?;
    parent_file
        .sync_all()
        .context("Failed to fsync parent directory")?;

    Ok(())
}

/// Hex encoding helper (since we don't want to add hex crate dependency)
mod hex {
    pub fn encode(bytes: &[u8]) -> String {
        bytes.iter().map(|b| format!("{:02x}", b)).collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_generate_worktree_id_format() {
        let path = PathBuf::from("/test/path");
        let timestamp = Utc::now();

        let id = generate_worktree_id(&path, timestamp);

        assert!(id.starts_with("wt:"));
        assert_eq!(id.len(), 11); // "wt:" + 8 hex chars
    }

    #[test]
    fn test_generate_worktree_id_deterministic() {
        let path = PathBuf::from("/test/path");
        let timestamp = DateTime::parse_from_rfc3339("2026-01-06T20:00:00Z")
            .unwrap()
            .with_timezone(&Utc);

        let id1 = generate_worktree_id(&path, timestamp);
        let id2 = generate_worktree_id(&path, timestamp);

        assert_eq!(id1, id2);
    }
}
